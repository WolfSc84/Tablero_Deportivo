// Librerias Funciones de tiempo DS3231
#include <Wire.h>
#include "RTClib.h"

//Libreria SPI para manejo de DMD y RF
#include <SPI.h>

// Librerias Funciones DMD
#include <DMD2.h>
#include "D:\Wolfgang Santamaria\Documents\Arduino\libraries\DMD2\fonts\Arial_black_16.h"

// Dimensiones del aviso Led
#define ROW 1
#define COLUMN 3

// Dimensiones del display
SoftDMD dmd(COLUMN, ROW);

// Dimensiones del panel utilizado en el display
DMD_TextBox box(dmd, 0, 0, 32, 16);

// Tipo de fuente a utilizar
#define FONT Arial_Black_16

// Inicializacion del objeto RTC
RTC_DS3231 rtc;

//Vector con los datos a recibir
char datos[6];

//Contador de datos recibidos
int count = 0;

//Cadena de caracteres recibida
char data;

//Variables para el control de tiempo
char daysOfTheWeek[7][12] = {"Domingo", "Lunes", "Martes", "Miercoles", "Jueves", "Viernes", "Sabado"};
int minutero = 0;
int ano = 0, mes = 0, dia = 0, hora = 0 , minuto = 0, segundo = 0, dia_semana = 0, entrada = 0;
bool flag = false;

//Anadiendo funcion para emular puerto serial adicional
#include <SoftwareSerial.h>

//Definiendo pines como Tx y Rx para emular puerto serial
SoftwareSerial mySerial(2, 3); // RX, TX

//Indicador LED de recepcion
#define PIN_LED 4

//Indicador FLAG de datos disponibles
#define PIN_FLAG 5

// Arranque inicial del sistema
void setup() {
  //Inicializamos el puerto serie
  Serial.begin(9600);
  Serial.println("Iniciando...");

  //Inicializamos el puerto serie emulado SoftwareSerial
  mySerial.begin(9600);

  // Configuracion inicial del reloj
  if (! rtc.begin()) {
    Serial.println("No se puede encontrar Reloj RTC!!");
    while (1);
  } else {
    Serial.println("RTC detectado!");
    Serial.println();
    Serial.println("Verificando estado de energia y configuracion de tiempo actualmente en el RTC.");
    Serial.println();
  }

  //Verificar si el reloj no tiene bateria y se encuentra desincronizado
  if (rtc.lostPower()) {
    Serial.println("RTC sin energia. Configurando el tiempo!");
    Serial.println();
    // Esta linea setea el RTC a la fecha y tiempo de esta compilacion
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
    // En caso de necesitarse definir el tiempo del reloj manualmente se ejecutaria esta linea con fecha y tiempo de forma explicita, por ejemplo:
    // Enero 21, 2021 a las 3am:
    //rtc.adjust(DateTime(2021, 1, 21, 03, 0, 0));
  } else {
    Serial.println("RTC con configuracion de tiempo valida!");
    Serial.println();
  }

  // Configuracion inicial de la pantalla
  dmd.setBrightness(255);
  dmd.selectFont(Arial_Black_16);
  dmd.begin();
  dmd.clearScreen();

  //Led indicador de datos recibidos
  pinMode(PIN_LED, OUTPUT);

  //Indicador de datos disponibles
  pinMode(PIN_FLAG, INPUT);
}

void loop() {
  // put your main code here, to run repeatedly:
  if (mySerial.available() > 0 && digitalRead(PIN_FLAG)) {
    //delay(100);
    //mySerial.flush();
    //delay(50);
    data = mySerial.read();
    //count++;
    Serial.print("Los datos recibidos son: ");
    Serial.println(data);
    mySerial.flush();
    // }
  }
  //if (count == 6) {

  //}

  //  tiempo();
  //  if (minutero != minuto) {
  //    dmd.clearScreen();
  //    minutero = minuto;
  //    pantalla_hora();
  //  }

}

//Funcion tiempo
void tiempo() {
  DateTime now = rtc.now();
  hora = now.hour();
  minuto = now.minute();
  segundo = now.second();
}

//Funcion mostrar en pantalla LED informacion
void pantalla_hora() {
  int decenas_horas; int unidad_horas; int decenas_minutos; int unidad_minutos; int decenas_segundos; int unidad_segundos;
  dmd.clearScreen();
  if (hora <= 9) {
    decenas_horas = 0;
    unidad_horas = hora;
    dmd.drawString(5, 1, String(decenas_horas));
    dmd.drawString(18, 1, String(unidad_horas));
    Serial.print(decenas_horas, DEC);
    Serial.print(unidad_horas, DEC);
  } else {
    decenas_horas = hora / 10;
    unidad_horas = hora - (decenas_horas * 10);
    dmd.drawString(5, 1, String(decenas_horas));
    dmd.drawString(18, 1, String(unidad_horas));
    Serial.print(hora, DEC);
  }
  Serial.print(':');
  dmd.drawString(30, 1, ":");
  if (minuto <= 9) {
    decenas_minutos = 0;
    unidad_minutos = minuto;;
    dmd.drawString(37, 1, String(decenas_minutos));
    dmd.drawString(51, 1, String(unidad_minutos));
    Serial.print(decenas_minutos, DEC);
    Serial.print(unidad_minutos, DEC);
  } else {
    decenas_minutos = minuto / 10;
    unidad_minutos = minuto - (decenas_minutos * 10);
    dmd.drawString(37, 1, String(decenas_minutos));
    dmd.drawString(51, 1, String(unidad_minutos));
    Serial.print(minuto, DEC);
  }
  Serial.print(':');
  dmd.drawString(63, 1, ":");
  if (segundo > 9) {
    decenas_segundos = segundo / 10;
    unidad_segundos = segundo - (decenas_segundos * 10);
    dmd.drawString(70, 1, String(decenas_segundos));
    dmd.drawString(84, 1, String(unidad_segundos));
    Serial.print(decenas_segundos, DEC);
    Serial.print(unidad_segundos, DEC);
  } else {
    decenas_segundos = 0;
    unidad_segundos = segundo;
    dmd.drawString(70, 1, String(decenas_segundos));
    dmd.drawString(84, 1, String(unidad_segundos));
    Serial.print(segundo, DEC);
  }
  Serial.println();
}
